# Test 1
**Input**: 
```
1 1
```
**Output**: 
```
1
```
**Explanation**: This test case checks the basic functionality of the function with the smallest possible input values. It ensures that the function correctly identifies the only valid pair (1,1) that satisfies the given conditions.

# Test 2
**Input**: 
```
2 3
```
**Output**: 
```
3
```
**Explanation**: This test case verifies the function's ability to handle small input values and identify multiple valid pairs (1,1), (2,1), and (2,2) that satisfy the conditions.

# Test 3
**Input**: 
```
3 5
```
**Output**: 
```
4
```
**Explanation**: This test case checks the function's behavior with slightly larger input values and ensures it correctly identifies the valid pairs (1,1), (2,1), (3,1), and (3,3) that satisfy the conditions.

# Test 4
**Input**: 
```
10 8
```
**Output**: 
```
14
```
**Explanation**: This test case evaluates the function's performance with moderate-sized input values and verifies it correctly identifies the 14 valid pairs that satisfy the conditions.

# Test 5
**Input**: 
```
100 1233
```
**Output**: 
```
153
```
**Explanation**: This test case checks the function's ability to handle larger input values and ensures it correctly identifies the 153 valid pairs that satisfy the conditions.

# Test 6
**Input**: 
```
1000000 1145141
```
**Output**: 
```
1643498
```
**Explanation**: This test case evaluates the function's performance with very large input values and verifies it correctly identifies the 1643498 valid pairs that satisfy the conditions.

# Test 7
**Input**: 
```
1 1000000
```
**Output**: 
```
1
```
**Explanation**: This test case checks the function's behavior when one of the input values is extremely large and the other is minimal. It ensures the function correctly identifies the only valid pair (1,1) that satisfies the conditions.

# Test 8
**Input**: 
```
1000000 1
```
**Output**: 
```
1
```
**Explanation**: This test case is similar to Test 7 but with the input values reversed. It verifies the function's behavior when one of the input values is extremely large and the other is minimal, ensuring it correctly identifies the only valid pair (1,1) that satisfies the conditions.

# Test 9
**Input**: 
```
0 1000000
```
**Output**: 
```
0
```
**Explanation**: This test case evaluates the function's behavior with an invalid input value (0) and ensures it correctly handles this edge case by returning 0, as there are no valid pairs.

# Test 10
**Input**: 
```
1000000 0
```
**Output**: 
```
0
```
**Explanation**: This test case is similar to Test 9 but with the invalid input value in the second position. It verifies the function's behavior with an invalid input value and ensures it correctly handles this edge case by returning 0, as there are no valid pairs.

# Test 11
**Input**: 
```
-1 1000000
```
**Output**: 
```
Error or Exception
```
**Explanation**: This test case checks the function's behavior with a negative input value, which is outside the specified range. It ensures the function correctly handles this invalid input by throwing an error or exception.

# Test 12
**Input**: 
```
1000000 -1
```
**Output**: 
```
Error or Exception
```
**Explanation**: This test case is similar to Test 11 but with the negative input value in the second position. It verifies the function's behavior with a negative input value and ensures it correctly handles this invalid input by throwing an error or exception.

# Test 13
**Input**: 
```
1000000 1000000
```
**Output**: 
```
1643498
```
**Explanation**: This test case evaluates the function's performance with extremely large input values and verifies it correctly identifies the 1643498 valid pairs that satisfy the conditions.

# Test 14
**Input**: 
```
2 2
```
**Output**: 
```
3
```
**Explanation**: This test case checks the function's behavior with small input values and ensures it correctly identifies the 3 valid pairs (1,1), (1,2), and (2,2) that satisfy the conditions.

# Test 15
**Input**: 
```
3 3
```
**Output**: 
```
4
```
**Explanation**: This test case verifies the function's ability to handle small input values and ensures it correctly identifies the 4 valid pairs (1,1), (1,3), (2,2), and (3,3) that satisfy the conditions.

These test cases cover a wide range of scenarios, including basic functionality, edge cases, and extreme input values, to ensure the function's robustness, reliability, and scalability.