# Test 1
**Input**: 
```
3 1
2 3
3 1
3
```
**Output**: 
```
Ron
```
This test case checks the basic functionality of the function when the tree has three nodes and the stone is initially placed on the third node.

# Test 2
**Input**: 
```
5 1
1 2
2 3
3 4
4 5
5
```
**Output**: 
```
Hermione
```
This test case verifies the function's behavior when the tree has five nodes and the stone is initially placed on the fifth node.

# Test 3
**Input**: 
```
2 1
1 2
1
```
**Output**: 
```
Ron
```
This test case checks the function's behavior when the tree has only two nodes and the stone is initially placed on the first node.

# Test 4
**Input**: 
```
4 1
1 2
2 3
3 4
4
```
**Output**: 
```
Hermione
```
This test case verifies the function's behavior when the tree has four nodes and the stone is initially placed on the fourth node.

# Test 5
**Input**: 
```
6 1
1 2
2 3
3 4
4 5
5 6
6
```
**Output**: 
```
Hermione
```
This test case checks the function's behavior when the tree has six nodes and the stone is initially placed on the sixth node.

# Test 6
**Input**: 
```
3 1
1 2
2 3
2
```
**Output**: 
```
Ron
```
This test case verifies the function's behavior when the tree has three nodes and the stone is initially placed on the second node.

# Test 7
**Input**: 
```
5 1
1 2
2 3
3 4
4 5
1
```
**Output**: 
```
Ron
```
This test case checks the function's behavior when the tree has five nodes and the stone is initially placed on the first node.

# Test 8
**Input**: 
```
4 1
1 2
2 3
3 4
3
```
**Output**: 
```
Ron
```
This test case verifies the function's behavior when the tree has four nodes and the stone is initially placed on the third node.

# Test 9
**Input**: 
```
6 1
1 2
2 3
3 4
4 5
5 6
3
```
**Output**: 
```
Ron
```
This test case checks the function's behavior when the tree has six nodes and the stone is initially placed on the third node.

# Test 10
**Input**: 
```
2 1
1 2
2
```
**Output**: 
```
Hermione
```
This test case verifies the function's behavior when the tree has only two nodes and the stone is initially placed on the second node.

These test cases cover various scenarios, including different tree sizes, stone placements, and expected outputs. They ensure that the function behaves correctly under normal conditions and edge cases.