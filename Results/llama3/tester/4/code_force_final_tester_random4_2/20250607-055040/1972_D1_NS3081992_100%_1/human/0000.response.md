# Test 1
**Input**: 
```
1 1
```
**Output**: 
```
1
```
**Explanation**: This test case checks the basic functionality of the function with the smallest possible input values.

# Test 2
**Input**: 
```
2 3
```
**Output**: 
```
3
```
**Explanation**: This test case verifies the function's behavior with small input values, ensuring it can handle multiple pairs.

# Test 3
**Input**: 
```
3 5
```
**Output**: 
```
4
```
**Explanation**: This test case checks the function's ability to handle slightly larger input values and more pairs.

# Test 4
**Input**: 
```
10 8
```
**Output**: 
```
14
```
**Explanation**: This test case evaluates the function's performance with moderate-sized input values and a larger number of pairs.

# Test 5
**Input**: 
```
100 1233
```
**Output**: 
```
153
```
**Explanation**: This test case assesses the function's scalability with larger input values, ensuring it can handle a significant number of pairs efficiently.

# Test 6
**Input**: 
```
1000000 1145141
```
**Output**: 
```
1643498
```
**Explanation**: This test case pushes the function to its limits with extremely large input values, verifying its robustness and ability to handle a vast number of pairs.

# Test 7 (Edge Case)
**Input**: 
```
1 1000000
```
**Output**: 
```
1
```
**Explanation**: This edge case tests the function's behavior when one input value is minimal (1) and the other is maximal (1000000), ensuring it can handle extreme disparities in input values.

# Test 8 (Edge Case)
**Input**: 
```
1000000 1
```
**Output**: 
```
1
```
**Explanation**: Similar to Test 7, this edge case checks the function's behavior when the input values are reversed, ensuring symmetry in handling extreme disparities.

# Test 9 (Edge Case)
**Input**: 
```
0 0
```
**Output**: 
```
0
```
**Explanation**: This edge case evaluates the function's behavior with invalid input values (0), ensuring it can handle or reject such inputs appropriately.

# Test 10 (Edge Case)
**Input**: 
```
-1 -1
```
**Output**: 
```
0
```
**Explanation**: This edge case tests the function's behavior with negative input values, ensuring it can handle or reject such inputs appropriately.

# Test 11 (Edge Case)
**Input**: 
```
2147483647 2147483647
```
**Output**: 
```
2147483647
```
**Explanation**: This edge case pushes the function to its limits with the maximum possible input values for 32-bit integers, verifying its ability to handle extremely large inputs.

# Test 12 (Edge Case)
**Input**: 
```
1 0
```
**Output**: 
```
0
```
**Explanation**: This edge case checks the function's behavior when one input value is minimal (1) and the other is invalid (0), ensuring it can handle such edge cases appropriately.

# Test 13 (Edge Case)
**Input**: 
```
0 1
```
**Output**: 
```
0
```
**Explanation**: Similar to Test 12, this edge case checks the function's behavior when the input values are reversed, ensuring symmetry in handling edge cases.

# Test 14 (Edge Case)
**Input**: 
```
-1 0
```
**Output**: 
```
0
```
**Explanation**: This edge case evaluates the function's behavior with negative and zero input values, ensuring it can handle or reject such inputs appropriately.

# Test 15 (Edge Case)
**Input**: 
```
0 -1
```
**Output**: 
```
0
```
**Explanation**: Similar to Test 14, this edge case checks the function's behavior when the input values are reversed, ensuring symmetry in handling edge cases.