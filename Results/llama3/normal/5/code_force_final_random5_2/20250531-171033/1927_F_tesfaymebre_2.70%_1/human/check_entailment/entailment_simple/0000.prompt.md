
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Given an undirected weighted graph with n vertices and m edges. There is at
most one edge between each pair of vertices in the graph, and the graph does
not contain loops (edges from a vertex to itself). The graph is not
necessarily connected.

A cycle in the graph is called simple if it doesn't pass through the same
vertex twice and doesn't contain the same edge twice.

Find any simple cycle in this graph in which the weight of the lightest edge
is minimal.

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of test cases. Then follow the descriptions of the test cases.

The first line of each test case contains two integers n and m (3 \le n \le m
\le \min(\frac{n\cdot(n - 1)}{2}, 2 \cdot 10^5) ) — the size of the graph and
the number of edges.

The next m lines of the test case contain three integers u , v , and w (1 \le
u, v \le n , u \ne v , 1 \le w \le 10^6 ) — vertices u and v are connected by
an edge of weight w .

It is guaranteed that there is at most one edge between each pair of vertices.
Note that under the given constraints, there is always at least one simple
cycle in the graph.

It is guaranteed that the sum of the values of m for all test cases does not
exceed 2 \cdot 10^5 .

Output

For each test case, output a pair of numbers b and k , where:

  * b — the minimum weight of the edge in the found cycle, 
  * k — the number of vertices in the found cycle. 

On the next line, output k numbers from 1 to n — the vertices of the cycle in
traversal order.

Note that the answer always exists, as under the given constraints, there is
always at least one simple cycle in the graph.

Example

Input

    5
    
    6 6
    
    1 2 1
    
    2 3 1
    
    3 1 1
    
    4 5 1
    
    5 6 1
    
    6 4 1
    
    6 6
    
    1 2 10
    
    2 3 8
    
    3 1 5
    
    4 5 100
    
    5 6 40
    
    6 4 3
    
    6 15
    
    1 2 4
    
    5 2 8
    
    6 1 7
    
    6 3 10
    
    6 5 1
    
    3 2 8
    
    4 3 4
    
    5 3 6
    
    2 6 6
    
    5 4 5
    
    4 1 3
    
    6 4 5
    
    4 2 1
    
    3 1 7
    
    1 5 5
    
    4 6
    
    2 3 2
    
    1 3 10
    
    1 4 1
    
    3 4 7
    
    2 4 5
    
    1 2 2
    
    4 5
    
    2 1 10
    
    3 1 3
    
    4 2 6
    
    1 4 7
    
    2 3 3

Output

    1 3
    1 2 3 
    3 3
    6 4 5 
    1 5
    4 2 1 6 3 
    1 4
    1 4 3 2 
    3 3
    2 3 1

# Annotated Program:
from collections import defaultdict
import sys
import threading

class DSU:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.size = [1] * n
        self.min_edge = [float('inf')] * n

    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, a, b, w):
        parent_a = self.find(a)
        parent_b = self.find(b)
        self.min_edge[parent_a] = min(self.min_edge[parent_a], w)
        self.min_edge[parent_b] = min(self.min_edge[parent_b], w)
        if parent_a != parent_b:
            if self.size[parent_a] < self.size[parent_b]:
                (parent_a, parent_b) = (parent_b, parent_a)
            self.size[parent_a] += self.size[parent_b]
            self.min_edge[parent_a] = min(self.min_edge[parent_a], self.min_edge[parent_b])
            self.parent[parent_b] = parent_a
        return
if __name__ == '__main__':
    sys.setrecursionlimit(1 << 30)
    threading.stack_size(1 << 27)
    main_thread = threading.Thread(target=main)
    main_thread.start()
    main_thread.join()

#Function 1:
#State of the program right berfore the function call: stdin contains one input: an integer
    return int(sys.stdin.readline().strip())
    #The program returns an integer that was provided as input from stdin.


#Function 2:
#State of the program right berfore the function call: stdin contains one input: a string
    return sys.stdin.readline().strip()
    #The program returns a string that was provided as input from stdin, with any leading or trailing whitespace removed.


#Function 3:
#State of the program right berfore the function call: stdin contains a line of space-separated integers.
    return map(int, sys.stdin.readline().strip().split())
    #The program returns a map object containing integers from the line of space-separated integers in stdin, where each integer is a separate element in the map object.


#Function 4:
#State of the program right berfore the function call: stdin contains a line of space-separated integers
    return list(map(int, sys.stdin.readline().strip().split()))
    #The program returns a list of integers that were read from the standard input, where each integer was separated by a space.


#Function 5:
#State of the program right berfore the function call: stdin contains a line of text with space-separated values of any type and value.
    return list(sys.stdin.readline().strip().split())
    #The program returns a list of values that were provided as input through stdin, where each value is a string and was separated from other values by a space, and all leading and trailing whitespace characters have been removed.


#Function 6:
#State of the program right berfore the function call: n and m are positive integers, graph is a dictionary where keys are integers and values are lists of integers, edges is a list of tuples where each tuple contains three integers, dsu is an instance of the DSU class, _min_edge is a positive integer, node_u and node_v are integers, colors is a list of integers, and res is a list of integers.
    n, m = func_3()
    graph = defaultdict(list)
    edges = []
    for i in range(m):
        u, v, w = func_3()
        
        graph[u].append(v)
        
        graph[v].append(u)
        
        edges.append((w, u, v))
        
    #State: n is a positive integer, m is a positive integer greater than 2, graph is a dictionary with two keys u and v, edges is a list containing m tuples (w, u, v), dsu is an instance of the DSU class, _min_edge is a positive integer, node_u is an integer, node_v is an integer, colors is a list of integers, res is a list of integers, i is m-1, u, v, and w are assigned values from func_3(), graph[u] contains m values v, graph[v] contains m values u, edges contains m tuples (w, u, v)
    edges.sort(reverse=True)
    dsu = DSU(n + 1)
    _min_edge = float('inf')
    node_u = -1
    node_v = -1
    for (w, u, v) in edges:
        parent_u = dsu.find(u)
        
        parent_v = dsu.find(v)
        
        if parent_u == parent_v:
            dsu.union(u, v, w)
            if dsu.min_edge[parent_u] < _min_edge:
                _min_edge = dsu.min_edge[parent_u]
                node_u = u
                node_v = v
        else:
            dsu.union(u, v, w)
        
    #State: n is a positive integer, m is a positive integer greater than 2, graph is a dictionary with two keys u and v, edges is an empty list, dsu is an instance of the DSU class with n + 1 elements. If the parents of u and v in the dsu data structure are the same, then the parents of u and v are the same as the parent of the union of u and v in the dsu data structure. If the minimum edge of the parent of the union of u and v in the dsu data structure is less than _min_edge, then node_u is the first node of the last tuple in the edges list and node_v is the second node of the last tuple in the edges list. Otherwise, no changes are made. If the parents of u and v in the dsu data structure are not the same, then u and v are now in the same set in the dsu data structure, and the parents of u and v are the parent of the set containing u and v in the dsu data structure.
    colors = [0] * (n + 1)
    res = dfs(node_u, -1, [])
    print(_min_edge, len(res))
    #This is printed: (_min_edge, the length of the result of the dfs function with node_u as the starting node and an empty list as the third argument)
    print(*res)
    #This is printed: elements of the res list (where res is the result of the dfs function with node_u as the starting node and an empty list as the third argument)


#Function 7:
#State of the program right berfore the function call: curr and parent are integers representing vertices in a graph, path is a list of integers representing a path in the graph, graph is a dictionary where each key is a vertex and its corresponding value is a list of its neighboring vertices, colors is a list where each index represents a vertex and its corresponding value is the color of that vertex (1 for visited, 2 for fully visited), and node_v is an integer representing a specific vertex in the graph.
    if (colors[curr] == 1) :
        return path
        #The program returns a list of integers representing a path in the graph, where the path includes the vertex represented by 'curr' which has been visited (colors[curr] = 1), and other vertices that are part of the path.
    #State: *curr and parent are integers representing vertices in a graph, path is a list of integers representing a path in the graph, graph is a dictionary where each key is a vertex and its corresponding value is a list of its neighboring vertices, colors is a list where each index represents a vertex and its corresponding value is the color of that vertex (1 for visited, 2 for fully visited), and node_v is an integer representing a specific vertex in the graph. The color of the current vertex is not 1.
    colors[curr] = 1
    path.append(curr)
    for nei in graph[curr]:
        if colors[nei] != 2 and nei != parent:
            res = dfs(nei, curr, path)
            set_res = set(res)
            if res and node_v in set_res:
                return res
        
    #State: The loop has finished executing, and the current vertex has been fully explored. The color of the current vertex remains 1, indicating that it has been visited, and the current vertex remains in the path. The values of parent, graph, and node_v remain unchanged. The loop has iterated over all neighbors of the current vertex, and for each neighbor, the recursive call to dfs(nei, curr, path) has been made if the neighbor has not been visited before (colors[nei] != 2) and the neighbor is not the parent of the current vertex. If the recursive call returns a non-empty result and node_v is in the result, the function returns the result. Otherwise, the function returns None.
    colors[curr] = 2
    return []
    #The program returns an empty list.


#Function 8:
#State of the program right berfore the function call: test_cases is a non-negative integer.
    test_cases = func_1()
    for _ in range(test_cases):
        func_6()
        
    #State: `test_cases` is greater than or equal to 0, and the function `func_6()` has been executed `test_cases` times.




# Your response:
Reasoning:  
Correctness: **True** or **False**

