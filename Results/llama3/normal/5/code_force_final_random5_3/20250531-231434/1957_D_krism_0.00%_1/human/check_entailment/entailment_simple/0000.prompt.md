
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
You are given an array a_1, a_2, \ldots, a_n . Find the number of tuples (x,
y, z ) such that:

  * 1 \leq x \leq y \leq z \leq n , and 
  * f(x, y) \oplus f(y, z) > f(x, z) . 

We define f(l, r) = a_l \oplus a_{l + 1} \oplus \ldots \oplus a_{r} , where
\oplus denotes the [bitwise XOR
operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).

Input

The first line contains a single integer t (1 \leq t \leq 10^4 ) — the number
of test cases.

The first line of each test case contains a single integer n (1 \leq n \leq
10^5 ).

The second line of each test case contains n integers a_1, a_2, \ldots, a_n (1
\leq a_i \leq 10^9 ).

It is guaranteed that the sum of n over all test cases does not exceed 10^5 .

Output

For each test case, output a single integer on a new line — the number of
described tuples.

Example

Input

    3
    
    3
    
    6 2 4
    
    1
    
    3
    
    5
    
    7 3 7 2 1

Output

    4
    0
    16
    
Note

In the first case, there are 4 such tuples in the array [6, 2, 4] :

  * (1 , 2 , 2 ): (a_1 \oplus a_2) \oplus (a_2) = 4 \oplus 2 > (a_1 \oplus a_2) = 4 
  * (1 , 1 , 3 ): (a_1) \oplus (a_1 \oplus a_2 \oplus a_3) = 6 \oplus 0 > (a_1 \oplus a_2 \oplus a_3) = 0 
  * (1 , 2 , 3 ): (a_1 \oplus a_2) \oplus (a_2 \oplus a_3) = 4 \oplus 6 > (a_1 \oplus a_2 \oplus a_3) = 0 
  * (1 , 3 , 3 ): (a_1 \oplus a_2 \oplus a_3) \oplus (a_3) = 0 \oplus 4 > (a_1 \oplus a_2 \oplus a_3) = 0 

In the second test case, there are no such tuples.

# Annotated Program:
T = int(input())
for _ in range(T):
    func_1()

#State of the program right berfore the function call: stdin contains an integer t (1 <= t <= 10^4) followed by t test cases. Each test case consists of an integer n (1 <= n <= 10^5) followed by n integers a_1, a_2, ..., a_n (1 <= a_i <= 10^9).
    print('-----------------')
    #This is printed: -----------------
    n = int(input())
    arr = list(map(int, input().split()))
    prefix = [0]
    for v in arr:
        prefix.append(v ^ prefix[-1])
        
    #State: `prefix` is a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in `arr`, stdin contains t-1 test cases, n is an integer equal to the number of integers in the next test case, arr is an empty list
    print(arr, prefix)
    #This is printed: An empty list [], and a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in the empty list arr
    pre = [[0, 0] for _ in range(32)]
    suf = [[0, 0] for _ in range(32)]
    for i in range(32):
        pre[i][0] += 1
        
    #State: `prefix` is a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in arr, `stdin` contains t-1 test cases, `n` is an integer equal to the number of integers in the next test case, `arr` is an empty list, `pre` is a list of 32 lists, each containing one 32 and one 0, `suf` is a list of 32 lists, each containing two 0s, an empty list and a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in arr are printed, `i` is 31, 32 is a positive integer
    for i in range(n, 0, -1):
        cur = prefix[i]
        
        for j in range(32):
            if cur >> j & 1:
                suf[j][1] += 1
            else:
                suf[j][0] += 1
        
    #State: Output State: `prefix` is a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in arr, `stdin` contains t-1 test cases, `n` is greater than 0, `arr` is an empty list, `pre` is a list of 32 lists, each containing one 32 and one 0, `suf` is a list of 32 lists, if the current value of `cur` has a 1 at the j-th bit position, the j-th list contains two 0s except the j-th list which contains one 0 and one 1, otherwise the j-th list contains one 1 and one 0 except the j-th list which now contains one 1 and one 1, an empty list and a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in arr are printed, `i` is 0, `cur` is the XOR of all integers from the 0-th to the (n-1)-th index in arr, `j` is 0, 32 is greater than 0. If the j-th bit of `cur` is 1, `suf[j][1]` is increased by 1. Otherwise, `suf[j][0]` is increased by 1. The value of `suf[j][1]` or `suf[j][0]` is increased by 1 based on whether the j-th bit of `cur` is 1 or 0. The value of `suf[j][1]` or `suf[j][0]` is increased by 1 based on whether the j-th bit of `cur` is 1 or 0. The value of `suf[j][1]` or `suf[j][0]` is increased by 1 based on whether the j-th bit of `cur` is 1 or 0.
    #
    #In natural language, the output state after the loop executes all the iterations is that the loop has finished executing and the variables have reached their final values. The `prefix` list still contains the XOR of all integers from the 0-th to the (i-1)-th index in `arr`. The `stdin` still contains t-1 test cases. The `n` is still greater than 0. The `arr` is still an empty list. The `pre` is still a list of 32 lists, each containing one 32 and one 0. The `suf` is a list of 32 lists, where each list contains the count of 1s and 0s in the corresponding bit position of the XOR of all integers from the 0-th to the (i-1)-th index in `arr`. The `i` has reached 0, indicating that the loop has finished executing. The `cur` is the XOR of all integers from the 0-th to the (n-1)-th index in `arr`. The `j` has reached 0, indicating that the inner loop has finished executing. The value of `suf[j][1]` or `suf[j][0]` is increased by 1 based on whether the j-th bit of `cur` is 1 or 0.
    print(pre)
    #This is printed: a list of 32 lists, each containing one 32 and one 0
    print(suf)
    #This is printed: [[32, 0], [32, 0], ..., [32, 0]] (32 times)
    ans = 0
    for i in range(1, n + 1):
        y = arr[i - 1]
        
        k = y.bit_length() - 1
        
        ans += pre[k][0] * suf[k][0] + pre[k][1] * suf[k][1]
        
        c = prefix[i]
        
        for j in range(32):
            if c >> j & 1:
                pre[j][1] += 1
                suf[j][1] -= 1
            else:
                pre[j][0] += 1
                suf[j][0] -= 1
        
    #State: arr has n elements, prefix has n+1 elements, ans is the sum of the products of corresponding elements in pre and suf at index k for all iterations, i is n, j is 32, cur is the XOR of all integers from the 0-th to the (n-1)-th index in arr, pre is a list of 32 lists, each containing one 32 and one 2^(n-1) if the j-th bit of c is 1, otherwise one 33 and one 2^(n-1)-1, suf is a list of 32 lists, each containing one 32 and one -2^(n-1)+1 if the j-th bit of c is 1, otherwise one 31 and one 0, stdin contains t-1 test cases, n is greater than 0, an empty list and a list containing n+1 elements where the i-th element is the XOR of all integers from the 0-th to the (i-1)-th index in arr are printed, 32 is greater than 0, y is the element at index i-1 in arr, k is the bit length of y minus 1, c is the element at index i in prefix.
    print(ans)
    #This is printed: the sum of the products of corresponding elements in pre and suf at index k for all iterations (where pre and suf are lists of 32 lists, each containing two elements, and k is the bit length of y minus 1, and y is the last element of arr)



# Your response:
Reasoning:  
Correctness: **True** or **False**

