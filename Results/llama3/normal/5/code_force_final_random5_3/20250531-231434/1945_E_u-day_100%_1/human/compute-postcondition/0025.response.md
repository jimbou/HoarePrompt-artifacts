The variables in the loop head are low and high, so we can only adjust them. According to the code, whether the loop can execute depends on the variables low and high. If low + 1 is less than high, the loop can execute again. At the end of the last iteration, low and high are updated based on the comparison of arr[mid] and k. If arr[mid] > k, then high is now equal to mid which is at least low + 1. Otherwise, low is equal to mid, and high is at least mid + 2. In both cases, low + 1 is less than or equal to high, so for the loop to execute one more time, low + 1 must be less than high. Therefore, low and high need to be adjusted so that low + 1 is less than high.

State: **n is greater than 1, k is a positive integer such that 1 ≤ k ≤ n, arr is a list of distinct integers from 1 to n in arbitrary order, i is n-1, low + 1 is less than high, st is a set containing (low + high) // 2 and mid, and pos is either n-1 or its original value depending on whether arr[i] equals k.**