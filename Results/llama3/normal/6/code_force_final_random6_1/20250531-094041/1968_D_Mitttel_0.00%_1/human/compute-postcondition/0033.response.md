Postcondition: ***The loop will terminate when either `steps` equals `k` or a cycle is detected. If `steps` equals `k`, the final state will be: `start_pos` is a positive integer, `k` is a positive integer, `p` is a list of positive integers, `a` is a list of non-negative integers, `len(p) = len(a) = n`, where `n` is a positive integer, `score` is the sum of `a[current_pos - 1]` for each iteration, `current_pos` is the last position visited, `steps` equals `k`, `visited` is a dictionary with `k` entries: each position visited mapped to its corresponding step, and `cycle_start` is -1. If a cycle is detected, the final state will be: `start_pos` is a positive integer, `k` is a positive integer, `p` is a list of positive integers, `a` is a list of non-negative integers, `len(p) = len(a) = n`, where `n` is a positive integer, `score` is the sum of `a[current_pos - 1]` for each iteration plus full_cycles * cycle_score plus a[current_pos - 1] plus a[current_pos - 1] plus ... plus a[current_pos - 1] (remainder_steps times), `current_pos` is `p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (remainder_steps times), `steps` is less than `k`, `visited` is a dictionary with entries: each position visited mapped to its corresponding step, `cycle_start` is not -1, `cycle_length` is equal to `cycle_length`, `cycle_score` is the sum of `a[cycle_pos - 1]` for each iteration plus `a[cycle_pos - 1]` plus `a[cycle_pos - 1]` plus ... plus `a[cycle_pos - 1]` (cycle_length times), `cycle_pos` is `p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (cycle_length times), `remaining_steps` is 0, `full_cycles` is the integer division of `remaining_steps` by `cycle_length`, and `remainder_steps` is 0.***