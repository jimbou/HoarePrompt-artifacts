
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Bodya and Sasha found a permutation p_1,\dots,p_n and an array a_1,\dots,a_n .
They decided to play a well-known "Permutation game".

A permutation of length n is an array consisting of n distinct integers from 1
to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but
[1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is
also not a permutation (n=3 but there is 4 in the array).

Both of them chose a starting position in the permutation.

The game lasts k turns. The players make moves simultaneously. On each turn,
two things happen to each player:

  * If the current position of the player is x , his score increases by a_x . 
  * Then the player either stays at his current position x or moves from x to p_x . 

The winner of the game is the player with the higher score after exactly k
turns.

Knowing Bodya's starting position P_B and Sasha's starting position P_S ,
determine who wins the game if both players are trying to win.

Input

The first line contains a single integer t (1\le t\le 10^4 ) — the number of
testcases.

The first line of each testcase contains integers n , k , P_B , P_S (1\le
P_B,P_S\le n\le 2\cdot 10^5 , 1\le k\le 10^9 ) — length of the permutation,
duration of the game, starting positions respectively.

The next line contains n integers p_1,\dots,p_n (1 \le p_i \le n ) — elements
of the permutation p .

The next line contains n integers a_1,\dots,a_n (1\le a_i\le 10^9 ) — elements
of array a .

It is guaranteed that the sum of values of n over all test cases does not
exceed 2 \cdot 10^5 .

Output

For each testcase output:

  * "Bodya" if Bodya wins the game. 
  * "Sasha" if Sasha wins the game. 
  * "Draw" if the players have the same score. 

Example

Input

    10
    
    4 2 3 2
    
    4 1 2 3
    
    7 2 5 6
    
    10 8 2 10
    
    3 1 4 5 2 7 8 10 6 9
    
    5 10 5 1 3 7 10 15 4 3
    
    2 1000000000 1 2
    
    1 2
    
    4 4
    
    8 10 4 1
    
    5 1 4 3 2 8 6 7
    
    1 1 2 1 2 100 101 102
    
    5 1 2 5
    
    1 2 4 5 3
    
    4 6 9 4 2
    
    4 2 3 1
    
    4 1 3 2
    
    6 8 5 3
    
    6 9 5 4
    
    6 1 3 5 2 4
    
    6 9 8 9 5 10
    
    4 8 4 2
    
    2 3 4 1
    
    5 2 8 7
    
    4 2 3 1
    
    4 1 3 2
    
    6 8 5 3
    
    2 1000000000 1 2
    
    1 2
    
    1000000000 2

Output

    Bodya
    Sasha
    Draw
    Draw
    Bodya
    Sasha
    Sasha
    Sasha
    Sasha
    Bodya
    
Note

Below you can find the explanation for the first testcase, where the game
consists of k=2 turns.

Turn| Bodya's position| Bodya's score| Bodya's move| Sasha's position| Sasha's
score| Sasha's move  
---|---|---|---|---|---|---  
first| 3 | 0 + a_3 = 0 + 5 = 5 | stays on the same position| 2 | 0 + a_2 = 0 + 2 = 2 | moves to p_2=1   
second| 3 | 5 + a_3 = 5 + 5 = 10 | stays on the same position| 1 | 2 + a_1 = 2 + 7 = 9 | stays on the same position  
final results| 3 | 10 | | 1 | 9 |   
  
As we may see, Bodya's score is greater, so he wins the game. It can be shown
that Bodya always can win this game.

# Annotated Functions:
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: n is a positive integer, k is a positive integer, PB and PS are positive integers such that 1 <= PB <= n and 1 <= PS <= n, p is a list of n distinct integers from 1 to n, and a is a list of n positive integers.
    bodya_score = calculate_score(PB)
    sasha_score = calculate_score(PS)
    if (bodya_score > sasha_score) :
        return 'Bodya'
        #The program returns the string 'Bodya'.
    else :
        if (sasha_score > bodya_score) :
            return 'Sasha'
            #The program returns the string 'Sasha'.
        else :
            return 'Draw'
            #The program returns the string 'Draw'.

#Overall this is what the function does:This function compares the scores of two players, 'Bodya' and 'Sasha', calculated by the function calculate_score for the given inputs PB and PS, and returns the winner as a string. If Bodya's score is higher, it returns 'Bodya'. If Sasha's score is higher, it returns 'Sasha'. If the scores are equal, it returns 'Draw'.

#Function 2:
#State of the program right berfore the function call: start_pos is a positive integer, k is a positive integer, p is a list of positive integers, a is a list of non-negative integers, and len(p) = len(a) = n, where n is a positive integer.
    score = 0
    current_pos = start_pos
    steps = 0
    visited = {}
    cycle_start = -1
    while steps < k:
        if current_pos in visited:
            cycle_start = visited[current_pos]
            break
        
        visited[current_pos] = steps
        
        score += a[current_pos - 1]
        
        steps += 1
        
        if steps >= k:
            return score
        
        current_pos = p[current_pos - 1]
        
    #State: The loop will terminate when either `steps` equals `k` or a cycle is detected. If `steps` equals `k`, the final state will be: `start_pos` is a positive integer, `k` is a positive integer, `p` is a list of positive integers, `a` is a list of non-negative integers, `len(p) = len(a) = n`, where `n` is a positive integer, `score` is the sum of `a[current_pos - 1]` for each iteration, `current_pos` is the last position visited, `steps` equals `k`, `visited` is a dictionary with `k` entries: each position visited mapped to its corresponding step, and `cycle_start` is -1. If a cycle is detected, the final state will be: `start_pos` is a positive integer, `k` is a positive integer, `p` is a list of positive integers, `a` is a list of non-negative integers, `len(p) = len(a) = n`, where `n` is a positive integer, `score` is the sum of `a[current_pos - 1]` for each iteration, `current_pos` is the position where the cycle starts, `steps` is less than `k`, `visited` is a dictionary with entries: each position visited mapped to its corresponding step, and `cycle_start` is the step where the cycle starts.
    if (cycle_start != -1) :
        cycle_length = steps - cycle_start
        cycle_score = 0
        cycle_pos = current_pos
        for _ in range(cycle_length):
            cycle_score += a[cycle_pos - 1]
            
            cycle_pos = p[cycle_pos - 1]
            
        #State: start_pos is a positive integer, k is a positive integer, p is a list of positive integers, a is a list of non-negative integers, len(p) = len(a) = n, where n is a positive integer, score is the sum of a[current_pos - 1] for each iteration, current_pos is the position where the cycle starts, steps is less than k, visited is a dictionary with entries: each position visited mapped to its corresponding step, cycle_start is not -1, cycle_length is equal to cycle_length, cycle_score is the sum of a[cycle_pos - 1] for each iteration plus a[cycle_pos - 1] plus a[cycle_pos - 1] plus ... plus a[cycle_pos - 1] (cycle_length times), cycle_pos is p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (cycle_length times).
        remaining_steps = k - steps
        full_cycles = remaining_steps // cycle_length
        remainder_steps = remaining_steps % cycle_length
        score += full_cycles * cycle_score
        for _ in range(remainder_steps):
            score += a[current_pos - 1]
            
            current_pos = p[current_pos - 1]
            
        #State: start_pos is a positive integer, k is a positive integer, p is a list of positive integers, a is a list of non-negative integers, len(p) = len(a) = n, where n is a positive integer, score is the sum of a[current_pos - 1] for each iteration plus full_cycles * cycle_score plus a[current_pos - 1] plus a[current_pos - 1] plus ... plus a[current_pos - 1] (remainder_steps times), current_pos is p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (remainder_steps times), steps is less than k, visited is a dictionary with entries: each position visited mapped to its corresponding step, cycle_start is not -1, cycle_length is equal to cycle_length, cycle_score is the sum of a[cycle_pos - 1] for each iteration plus a[cycle_pos - 1] plus a[cycle_pos - 1] plus ... plus a[cycle_pos - 1] (cycle_length times), cycle_pos is p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (cycle_length times), remaining_steps is 0, full_cycles is the integer division of remaining_steps by cycle_length, remainder_steps is 0.
    #State: *The loop will terminate when either `steps` equals `k` or a cycle is detected. If `steps` equals `k`, the final state will be: `start_pos` is a positive integer, `k` is a positive integer, `p` is a list of positive integers, `a` is a list of non-negative integers, `len(p) = len(a) = n`, where `n` is a positive integer, `score` is the sum of `a[current_pos - 1]` for each iteration, `current_pos` is the last position visited, `steps` equals `k`, `visited` is a dictionary with `k` entries: each position visited mapped to its corresponding step, and `cycle_start` is -1. If a cycle is detected, the final state will be: `start_pos` is a positive integer, `k` is a positive integer, `p` is a list of positive integers, `a` is a list of non-negative integers, `len(p) = len(a) = n`, where `n` is a positive integer, `score` is the sum of `a[current_pos - 1]` for each iteration plus full_cycles * cycle_score plus a[current_pos - 1] plus a[current_pos - 1] plus ... plus a[current_pos - 1] (remainder_steps times), `current_pos` is `p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (remainder_steps times), `steps` is less than `k`, `visited` is a dictionary with entries: each position visited mapped to its corresponding step, `cycle_start` is not -1, `cycle_length` is equal to `cycle_length`, `cycle_score` is the sum of `a[cycle_pos - 1]` for each iteration plus `a[cycle_pos - 1]` plus `a[cycle_pos - 1]` plus ... plus `a[cycle_pos - 1]` (cycle_length times), `cycle_pos` is `p[p[p[p...[p[cycle_pos - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1] - 1 (cycle_length times), `remaining_steps` is 0, `full_cycles` is the integer division of `remaining_steps` by `cycle_length`, and `remainder_steps` is 0.
    return score
    #The program returns the score which is the sum of `a[current_pos - 1]` for each iteration, where `a` is a list of non-negative integers, `current_pos` is the last position visited, and the number of iterations is equal to `k` if no cycle is detected, or the number of iterations is equal to `full_cycles * cycle_length + remainder_steps` if a cycle is detected, where `full_cycles` is the integer division of `remaining_steps` by `cycle_length`, `cycle_length` is the length of the cycle, `remainder_steps` is the remainder of `remaining_steps` divided by `cycle_length`, and `remaining_steps` is `k` minus the number of steps taken before the cycle is detected.

#Overall this is what the function does:This function calculates the total score by traversing a list of positions and accumulating scores from a corresponding list of non-negative integers. It starts at a given position and moves to the next position based on the list of positions. If it detects a cycle, it calculates the score for the cycle and adds it to the total score. The function returns the total score after traversing the list for a specified number of steps or detecting a cycle.

#Function 3:
#State of the program right berfore the function call: data is a list of strings where each string represents an integer or a space-separated list of integers, index is a non-negative integer, t is a positive integer, n is a positive integer, k is a positive integer, PB and PS are positive integers such that 1 <= PB, PS <= n, p is a list of positive integers such that 1 <= p_i <= n for all i, a is a list of positive integers such that 1 <= a_i <= 10^9 for all i.
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        k = int(data[index + 1])
        
        PB = int(data[index + 2])
        
        PS = int(data[index + 3])
        
        index += 4
        
        p = list(map(int, data[index:index + n]))
        
        index += n
        
        a = list(map(int, data[index:index + n]))
        
        index += n
        
        result = func_1(n, k, PB, PS, p, a)
        
        results.append(result)
        
    #State: data is a list of strings where each string represents an integer or a space-separated list of integers, index is 1 + 4 + (t - 1)n + (t - 1)n, t is 0, results is a list containing the results of func_1(n, k, PB, PS, p, a) for all iterations, n is an integer, k is an integer, PB is an integer, PS is an integer, p is a list of n integers, a is a list of n integers, stdin is empty
    for result in results:
        print(result)
        
    #State: `data` is a list of strings where each string represents an integer or a space-separated list of integers, `index` is 1 + 4 + (t - 1)n + (t - 1)n, `t` is 0, `results` is a list containing the results of func_1(n, k, PB, PS, p, a) for all iterations, `result` is the last result in the list, `n` is an integer, `k` is an integer, `PB` is an integer, `PS` is an integer, `p` is a list of n integers, `a` is a list of n integers, `stdin` is empty, and the last result in the list of results is being printed

#Overall this is what the function does:Reads input from standard input, processes it according to the func_1 function, and prints the results. The input is expected to be a list of strings representing integers or space-separated lists of integers, which are then parsed into various variables (t, n, k, PB, PS, p, a) and passed to func_1. The function iterates over the input data, processing each set of variables and storing the results in a list. Finally, it prints each result in the list.




# Your response:
Reasoning:  
Correctness: **True** or **False**

