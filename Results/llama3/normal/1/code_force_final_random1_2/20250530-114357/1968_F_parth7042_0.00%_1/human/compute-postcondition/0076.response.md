Postcondition: **idx is incremented by 2, n is an integer greater than 0, equal to the value at data[idx - n - 2] before the code execution, q is an integer greater than 0 and equal to the value at data[idx - n - 1] before the code execution, a is a list of n + 1 integers where a[i] is equal to the value at data[idx - n - 2 + i - 1] before the code execution for all i in range(1, n + 1), pf is a list of n + 1 integers where pf[1] is equal to the value at data[idx - n - 2] before the code execution and pf[i] is equal to pf[i - 1] XOR the value at data[idx - n - 2 + i - 1] before the code execution for all i in range(2, n + 1), t remains greater than 1, results list contains an additional empty string at the end, i is n, mp is a dictionary where mp[pf[i]] contains the value i for all i in range(1, n + 1), l is an integer equal to the value at data[idx - 2] before the code execution, r is an integer equal to the value at data[idx - 1] before the code execution, x is an integer equal to pf[r] XOR pf[l - 1], v1 is a list of values from mp where the key is pf[r], v2 is a list of values from mp where the key is pf[l - 1], it1 is the insertion point for l in v1 to maintain sorted order, and it2 is the insertion point for r in v2 to maintain sorted order minus 1. The current value of it1 is less than the length of v1, the current value of it2 is greater than or equal to 0, the current value of v1[it1] is less than or equal to r, and the current value of v2[it2] is greater than or equal to l. If x is 0, results list contains two additional strings: an empty string at the end and 'YES' appended after that.**