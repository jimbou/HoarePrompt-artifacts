
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Nene gave you an array of integers a_1, a_2, \ldots, a_n of length n .

You can perform the following operation no more than 5\cdot 10^5 times
(possibly zero):

  * Choose two integers l and r such that 1 \le l \le r \le n , compute x as \operatorname{MEX}(\\{a_l, a_{l+1}, \ldots, a_r\\}) , and simultaneously set a_l:=x, a_{l+1}:=x, \ldots, a_r:=x . 

Here, \operatorname{MEX} of a set of integers \\{c_1, c_2, \ldots, c_k\\} is
defined as the smallest non-negative integer m which does not occur in the set
c .

Your goal is to maximize the sum of the elements of the array a . Find the
maximum sum and construct a sequence of operations that achieves this sum.
Note that you don't need to minimize the number of operations in this
sequence, you only should use no more than 5\cdot 10^5 operations in your
solution.

Input

The first line contains an integer n (1 \le n \le 18 ) — the length of the
array a .

The second line contains n integers a_1,a_2,\ldots,a_n (0\leq a_i \leq 10^7 )
— the array a .

Output

In the first line, output two integers s and m (0\le m\le 5\cdot 10^5 ) — the
maximum sum of elements of the array a and the number of operations in your
solution.

In the i -th of the following m lines, output two integers l and r (1 \le l
\le r \le n ), representing the parameters of the i -th operation.

It can be shown that the maximum sum of elements of the array a can always be
obtained in no more than 5 \cdot 10^5 operations.

Examples

Input

    2
    
    0 1

Output

    4 1
    1 2
    
Input

    3
    
    1 3 9

Output

    13 0
    
Input

    4
    
    1 100 2 1

Output

    105 2
    3 3
    3 4
    
Input

    1
    
    0

Output

    1 1
    1 1
    
Note

In the first example, after the operation with l=1 and r=2 the array a becomes
equal to [2,2] . It can be shown that it is impossible to achieve a larger sum
of the elements of a , so the answer is 4 .

In the second example, the initial sum of elements is 13 which can be shown to
be the largest.

In the third example, the array a changes as follows:

  * after the first operation (l=3 , r=3 ), the array a becomes equal to [1,100,0,1] ; 
  * after the second operation (l=3 , r=4 ), the array a becomes equal to [1,100,2,2] . 

It can be shown that it is impossible to achieve a larger sum of the elements
of a , so the answer is 105 .

# Annotated Program:
if __name__ == '__main__':
    func_3()

#Function 1:
#State of the program right berfore the function call: a is a list of non-negative integers, l and r are non-negative integers such that 0 <= l <= r < len(a), ops is a list of tuples of non-negative integers.
    if (l == r) :
        if (a[l] != 0) :
            ops.append((l, l))
            a[l] = 0
        #State: *a is a list of non-negative integers, l and r are non-negative integers such that 0 <= l <= r < len(a) and l is equal to r, ops is a list of tuples of non-negative integers. If a[l] is not equal to 0, ops has an additional tuple (l, l) appended to it.
        return
        #The program returns nothing, as there is no return statement with a value. The state of the variables remains unchanged. The list 'a' still contains non-negative integers, 'l' and 'r' are still non-negative integers such that 0 <= l <= r < len(a) and l is equal to r, and 'ops' is still a list of tuples of non-negative integers. If a[l] is not equal to 0, ops still has an additional tuple (l, l) appended to it.
    #State: a is a list of non-negative integers, l and r are non-negative integers such that 0 <= l < r < len(a), ops is a list of tuples of non-negative integers.
    func_1(a, l + 1, r, ops)
    if (a[l] != r - l + 1) :
        ops.append((l, r))
        for i in range(l, r + 1):
            a[i] = r - l + 1
            
        #State: Output State: `a` is a list of non-negative integers, `l` is a non-negative integer, `r` is a non-negative integer such that `l` < `r` < `len(a)`, `ops` is a list of tuples of non-negative integers, `ops` now includes the tuple `(l, r)`, all elements in the sublist `a[l:r+1]` are equal to `r - l + 1`, `i` is `r`.
        #
        #In natural language, after the loop executes all the iterations, the sublist of `a` from index `l` to `r` (inclusive) will have all elements set to `r - l + 1`, and the loop counter `i` will be equal to `r`. The other variables `l`, `r`, and `ops` remain unchanged.
        func_1(a, l + 1, r, ops)
    #State: *`a` is a list of non-negative integers, `l` is a non-negative integer, `r` is a non-negative integer such that `l` < `r` < `len(a)`, `ops` is a list of tuples of non-negative integers. If `a[l]` is not equal to `r - l + 1`, then `ops` includes the tuple `(l, r)`, all elements in the sublist `a[l+1:r+1]` are equal to `r - l`, and `i` is `r`. Otherwise, no changes are made to `a`, `l`, `r`, `ops`, or `i`.


#Function 2:
#State of the program right berfore the function call: a is a list of non-negative integers.
    n = len(a)
    ops = []
    recursive_maximize_sum(0, n - 1)
    return sum(a), len(ops), ops
    #The program returns the sum of all non-negative integers in list 'a', the length of an empty list 'ops' which is 0, and the empty list 'ops' itself.


#Function 3:
#State of the program right berfore the function call: l and r are non-negative integers such that 0 <= l <= r < len(a), and a is a list of non-negative integers.
    s = sum(a[l:r + 1])
    if (s <= (r - l + 1) * (r - l + 1)) :
        func_1(a, l, r, ops)
        ops.append((l, r))
        for i in range(l, r + 1):
            a[i] = r - l + 1
            
        #State: `l` and `r` are non-negative integers such that 0 <= l <= r < len(a), `a` is a list of non-negative integers, all elements in `a` from index `l` to `r` (inclusive) are equal to `r - l + 1`, `s` is equal to `(r - l + 1)^2`, `ops` is a list containing a tuple of `(l, r)`, `i` is `r`.
    else :
        mx = max(a[l:r + 1])
        pos = a[l:r + 1].index(mx) + l
        if (pos != l) :
            recursive_maximize_sum(l, pos - 1)
        #State: l and r are non-negative integers such that 0 <= l <= r < len(a), a is a list of non-negative integers, s is the sum of the elements in a from index l to r (inclusive), mx is the maximum value in the sublist a[l:r + 1], and the current value of pos is the index of mx in the original list a. If pos is not equal to l, the function recursive_maximize_sum(l, pos - 1) has been called and returned.
        if (pos != r) :
            recursive_maximize_sum(pos + 1, r)
        #State: l and r are non-negative integers such that 0 <= l <= r < len(a), a is a list of non-negative integers, s is the sum of the elements in a from index l to r (inclusive), mx is the maximum value in the sublist a[l:r + 1], and the function has recursively maximized the sum for the sublists a[l:pos - 1] and a[pos + 1:r + 1] if pos is not equal to r, otherwise no further recursive calls are made.
    #State: *`l` and `r` are non-negative integers such that 0 <= l <= r < len(a), `a` is a list of non-negative integers, and `s` is the sum of the elements in `a` from index `l` to `r` (inclusive). If `s` is less than or equal to `(r - l + 1)^2`, all elements in `a` from index `l` to `r` (inclusive) are equal to `r - l + 1`, `s` is equal to `(r - l + 1)^2`, `ops` is a list containing a tuple of `(l, r)`, and `i` is `r`. Otherwise, the function has recursively maximized the sum for the sublists `a[l:pos - 1]` and `a[pos + 1:r + 1]` if `pos` is not equal to `r`, or no further recursive calls are made if `pos` is equal to `r`, and `mx` is the maximum value in the sublist `a[l:r + 1]`.


#Function 4:
#State of the program right berfore the function call: stdin contains two inputs: first an integer and then a space-separated list of integers. The integer is a positive integer and represents the length of the list. The list contains non-negative integers.
    n = int(input())
    a = list(map(int, input().split()))
    s, m, ops = func_2(a)
    print(s, m)
    #This is printed: s (the sum of the elements in list a), m (the maximum element in list a)
    for (l, r) in ops:
        print(l + 1, r + 1)
        
    #State: n is a positive integer, a is a list of non-negative integers, s is the sum of the elements in a, m is the maximum element in a, ops is a list of pairs of elements, stdin is empty, l is the first element of the last pair in ops, r is the second element of the last pair in ops, and the value of l + 1 and r + 1 are being printed




# Your response:
Reasoning:  
Correctness: **True** or **False**

