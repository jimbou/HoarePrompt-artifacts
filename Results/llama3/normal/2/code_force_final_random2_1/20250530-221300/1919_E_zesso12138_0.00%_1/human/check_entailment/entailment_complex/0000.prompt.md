
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
There is a hidden array a of size n consisting of only 1 and -1 . Let p be the
prefix sums of array a . More formally, p is an array of length n defined as
p_i = a_1 + a_2 + \ldots + a_i . Afterwards, array p is sorted in non-
decreasing order. For example, if a = [1, -1, -1, 1, 1] , then p = [1, 0, -1,
0, 1] before sorting and p = [-1, 0, 0, 1, 1] after sorting.

You are given the prefix sum array p after sorting, but you do not know what
array a is. Your task is to count the number of initial arrays a such that the
above process results in the given sorted prefix sum array p . As this number
can be large, you are only required to find it modulo 998\,244\,353 .

Input

Each test contains multiple test cases. The first line contains a single
integer t (1 \leq t \leq 1000 ) — the number of test cases. The description of
the test cases follows.

The first line of each test case contains a single integer n (1 \le n \le 5000
) — the size of the hidden array a .

The second line of each test case contains n integers p_1, p_2, \ldots, p_n
(|p_i| \le n ) — the n prefix sums of a sorted in non-decreasing order.

It is guaranteed that p_1 \le p_2 \le \ldots \le p_n .

It is guaranteed that the sum of n over all test cases does not exceed 5000 .

Output

For each test case, output the answer modulo 998\,244\,353 .

Example

Input

    5
    
    1
    
    0
    
    1
    
    1
    
    3
    
    -1 1 2
    
    5
    
    -1 0 0 1 1
    
    5
    
    -4 -3 -3 -2 -1

Output

    0
    1
    0
    3
    1
    
Note

In the first two test cases, the only possible arrays a for n = 1 are a = [1]
and a = [-1] . Their respective sorted prefix sum arrays p are p = [1] and p =
[-1] . Hence, there is no array a that can result in the sorted prefix sum
array p = [0] and there is exactly 1 array a that can result in the sorted
prefix sum array p = [1] .

In the third test case, it can be proven that there is no array a that could
result in the sorted prefix sum array p = [-1, 1, 2] .

In the fourth test case, the 3 possible arrays a that could result in the
sorted prefix sum array p = [-1, 0, 0, 1, 1] are:

  * a = [1, -1, 1, -1, -1] . The prefix sum array before sorting is p = [1, 0, 1, 0, -1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [1, -1, -1, 1, 1] . The prefix sum array before sorting is p = [1, 0, -1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 
  * a = [-1, 1, 1, -1, 1] . The prefix sum array before sorting is p = [-1, 0, 1, 0, 1] , which after sorting gives p = [-1, 0, 0, 1, 1] . 

For the fifth test case, the only possible array a that could result in the
sorted prefix sum array p = [-4, -3, -3, -2, -1] is a = [-1, -1, -1, -1, 1] .

# Annotated Functions:
MOD = 998244353
if __name__ == '__main__':
    func_2()

#Function 1:
#State of the program right berfore the function call: n is a positive integer, p is a list of integers of length n, and the elements of p are sorted in non-decreasing order.
    dp = [0] * (2 * n + 1)
    offset = n
    dp[offset] = 1
    for i in range(1, n + 1):
        new_dp = [0] * (2 * n + 1)
        
        for j in range(2 * n + 1):
            if dp[j] > 0:
                if j + 1 <= 2 * n:
                    new_dp[j + 1] = (new_dp[j + 1] + dp[j]) % MOD
                if j - 1 >= 0:
                    new_dp[j - 1] = (new_dp[j - 1] + dp[j]) % MOD
        
        dp = new_dp
        
    #State: n is a positive integer greater than or equal to 1, p is a list of integers of length n, and the elements of p are sorted in non-decreasing order, dp is a list of 2n+1 integers where dp[j - 1] is (dp[j - 1] + dp[j]) % MOD if j - 1 >= 0, otherwise dp[j + 1] is (dp[j] + dp[j + 1]) % MOD if j + 1 <= 2 * n, otherwise dp remains unchanged, offset is n, i is n, new_dp is a list of 2n+1 integers where new_dp[j + 1] is (new_dp[j + 1] + dp[j]) % MOD if j + 1 <= 2 * n, otherwise new_dp remains unchanged, 2 * n + 1 is at least 2 * n + 1, and j is 2 * n. If dp[j] is greater than 0, then new_dp[j - 1] is (new_dp[j - 1] + dp[j]) % MOD if j - 1 >= 0, otherwise new_dp remains unchanged. If j + 1 <= 2 * n, then new_dp[2 * n] is (new_dp[2 * n] + dp[2 * n - 1]) % MOD, otherwise new_dp remains unchanged. If j - 1 >= 0, then new_dp[2 * n - 1] is (new_dp[2 * n - 1] + dp[2 * n]) % MOD, otherwise new_dp remains unchanged. If dp[j] is not greater than 0, then new_dp remains unchanged.
    final_sum = p[-1] + offset
    return dp[final_sum]
    #The program returns dp[final_sum] where final_sum is p[-1] + n, and p[-1] is the last element of the list p which is a list of integers of length n, and the elements of p are sorted in non-decreasing order, and n is a positive integer greater than or equal to 1.

#Overall this is what the function does:Functionality: This function calculates and returns the value at a specific index in a dynamic programming (dp) table. The index is determined by adding the last element of a sorted list of integers (p) to the length of the list (n). The dp table is initialized with a length of 2n+1, and its values are updated iteratively based on the previous values, using modular arithmetic with a modulus (MOD). The function takes a positive integer n and a sorted list of integers p as input and returns an integer value from the dp table.

#Function 2:
#State of the program right berfore the function call: n is a positive integer and p is a list of integers of length n, sorted in non-decreasing order, such that the absolute value of each element in p is less than or equal to n.
    input = sys.stdin.read
    data = input().split()
    index = 0
    t = int(data[index])
    index += 1
    results = []
    for _ in range(t):
        n = int(data[index])
        
        index += 1
        
        p = list(map(int, data[index:index + n]))
        
        index += n
        
        result = func_1(n, p)
        
        results.append(result)
        
    #State: n is the integer value at index t*n+1 in data, p is a list of n integers from index t*n+2 to index (t+1)*n+1 in data, index is (t+1)*n+1, results contains the result of func_1(n, p) appended to its original value, data is a list of strings split from the input, stdin is empty
    for res in results:
        print(res)
        
    #State: `n` is the integer value at index `t*n+1` in `data`, `p` is a list of `n` integers from index `t*n+2` to index `(t+1)*n+1` in `data`, `index` is `(t+1)*n+1`, `results` is a list of results that must have at least as many results as the length of `results`, `res` is the last result in the list, `data` is a list of strings split from the input, `stdin` is empty, and the last result in the list of results which is `res` has been printed.

#Overall this is what the function does:Reads input from standard input, processes it into a list of integers and a count, calls the function func_1 with these values, and appends the result to a list of results. It repeats this process a specified number of times, then prints each result in the list.




# Your response:
Reasoning:  
Correctness: **True** or **False**

