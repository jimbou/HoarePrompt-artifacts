Postcondition: ***`n` is an integer, `k` is an integer, `ps` is the value of `p` at index `p[p[p[ps - 1] - 1] - 1] - 1`, `p` is a list of integers, `a` is a list of integers, `pathb` is a list containing elements where each element is the value of `a` at index `pb - 1`, `paths` is a list containing the value of `a` at index `ps - 1`, the value of `a` at index `ps - 1`, the value of `a` at index `p[ps - 1] - 1`, and the value of `a` at index `p[p[ps - 1] - 1] - 1` and has a length greater than `i + 1`, `vis` is a list of `n` values where all elements are 0 except for the element at index `ps - 1` which is 1, the element at index `p[ps - 1] - 1` which is 1, and the element at index `p[p[ps - 1] - 1] - 1` which is 1, `pb` is the value of `p` at index `pb - 1`, `resb` is the maximum value between its original value and the sum of `preb` and the product of `pathb[i]` and `k - i` for all `i` in range(len(`pathb`)) where `k >= i + 1`, `preb` is the sum of its original value and `pathb[i]` for all `i` in range(len(`pathb`)) where `k >= i + 1`, `pres` is the sum of its original value and `paths[i]` for all `i` in range(len(`paths`)) where `k >= i + 1` and is now increased by `paths[i]`, `ress` is the maximum value between its original value and the sum of `pres` and the product of `paths[i]` and `k - i` for all `i` in range(len(`paths`)) where `k >= i + 1` and is now updated to max(`ress`, `curr`), `i` is the value that caused the break if `k` is less than the length of `paths`, otherwise `i` is the length of `paths` + 1. If `k` is less than `i + 1`, we break out of the most internal loop or if statement. Otherwise, no change is made.***