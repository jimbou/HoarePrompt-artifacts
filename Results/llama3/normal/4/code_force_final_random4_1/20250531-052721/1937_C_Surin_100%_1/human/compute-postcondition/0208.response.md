Output State: **kp is n+1, n is an integer that must be at least 1, I and R remain in their initial state, g is 0, v2 is n-1, i is n, r2 remains assigned the original value of the input, and r is either a string containing the input value if r is '>' or an empty string if r is '=', prev is either n if r is '>' or n-1 if r is '=' or 0 or n-1 if r2 is '<', and the output buffer contains the string "? 0 0 1 1" followed by an empty line, and either "? [v1] [v1] [v2] [v2]" or "? [v1] [v1] [v2] [v2]" depending on the previous value of r, where v1 is either 0 or n-1 and v2 is n-1. If r is '=', then this is printed: "? [v1] [i] [v1] [prev]" where v1 is either 0 or n-1, i is n-1, and prev is either n-1 if r is '>' or n-2 if r is '=' or 0 or n-2 if r2 is '<', and this is printed: "? n-1 n-1 [prev] [prev]" where prev is either n-1 if r is '>' or n-2 if r is '=' or 0 or n-2 if r2 is '<'.**

The output state after the loop executes all the iterations is characterized by the following:

* `kp` remains `n+1`, and `n` is an integer that must be at least 1.
* `I` and `R` remain in their initial state.
* `g` is 0.
* `v2` is `n-1`.
* `i` is `n`.
* `r2` remains assigned the original value of the input.
* `r` is either a string containing the input value if `r` is '>' or an empty string if `r` is '='.
* `prev` is either `n` if `r` is '>' or `n-1` if `r` is '=' or 0 or `n-1` if `r2` is '<'.
* The output buffer contains the string "? 0 0 1 1" followed by an empty line, and either "? [v1] [v1] [v2] [v2]" or "? [v1] [v1] [v2] [v2]" depending on the previous value of `r`, where `v1` is either 0 or `n-1` and `v2` is `n-1`.
* If `r` is '=', then this is printed: "? [v1] [i] [v1] [prev]" where `v1` is either 0 or `n-1`, `i` is `n-1`, and `prev` is either `n-1` if `r` is '>' or `n-2` if `r` is '=' or 0 or `n-2` if `r2` is '<', and this is printed: "? n-1 n-1 [prev] [prev]" where `prev` is either `n-1` if `r` is '>' or `n-2` if `r` is '=' or 0 or `n-2` if `r2` is '<'.