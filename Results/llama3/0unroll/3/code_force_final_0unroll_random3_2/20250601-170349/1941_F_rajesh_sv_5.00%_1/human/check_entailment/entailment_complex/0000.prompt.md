
Your task is to determine if a given Python program is correct based on the problem description and the execution states of the program provided as comments. Assume valid inputs as described in the problem. The program is made of multiple functions and the program is **correct** only if all its functions together meet the problem description.

First explain your reasoning  then reply Correctness: **True**  if the given program is correct or Correctness: **False**  if the given program is incorrect.


# Problem:
Rudolf has prepared a set of n problems with complexities a_1 < a_2 < a_3 <
\dots < a_n . He is not entirely satisfied with the balance, so he wants to
add at most one problem to fix it.

For this, Rudolf came up with m models of problems and k functions. The
complexity of the i -th model is d_i , and the complexity of the j -th
function is f_j . To create a problem, he selects values i and j (1 \le i \le
m , 1 \le j \le k ) and by combining the i -th model with the j -th function,
he obtains a new problem with complexity d_i + f_j (a new element is inserted
into the array a ).

To determine the imbalance of the set, Rudolf sorts the complexities of the
problems in ascending order and finds the largest value of a_i - a_{i - 1} (i
> 1 ).

What is the minimum value of imbalance that Rudolf can achieve by adding at
most one problem, created according to the described rules?

Input

The first line of the input contains a single integer t (1 \le t \le 10^4 ) —
the number of testcases.

The first line of each test case contains three integers n , m , and k (2 \le
n \le 10^5 , 1 \le m, k \le 2 \cdot 10^5 ) — the number of prepared problems,
the number of models, and the number of functions, respectively.

The second line of each test case contains n integers a_1, a_2, a_3, \dots a_n
(1 \le a_i \le 2 \cdot 10^9 , a_i < a_{i+1} ) — the complexities of the
prepared problems.

The third line of each test case contains m integers d_1, d_2, d_3, \dots d_m
(1 \le d_i \le 10^9 ) — the complexities of the models.

The fourth line of each test case contains k integers f_1, f_2, f_3, \dots f_k
(1 \le f_i \le 10^9 ) — the complexities of the functions.

It is guaranteed that the sum of n over all testcases does not exceed 10^5 .

It is guaranteed that the sum of m over all testcases does not exceed 2 \cdot
10^5 .

It is guaranteed that the sum of k over all testcases does not exceed 2 \cdot
10^5 .

Output

For each testcase, output a single number — the minimum imbalance that Rudolf
can achieve.

Example

Input

    7
    
    5 5 5
    
    5 10 15 20 26
    
    11 14 16 13 8
    
    16 4 5 3 1
    
    7 6 5
    
    1 4 7 10 18 21 22
    
    2 3 5 7 4 2
    
    6 8 9 3 2
    
    7 6 5
    
    1 4 7 10 18 21 22
    
    2 3 5 7 4 2
    
    6 8 13 3 2
    
    5 6 3
    
    2 10 13 20 25
    
    11 6 10 16 14 5
    
    6 17 15
    
    4 2 2
    
    11 12 14 15
    
    19 14
    
    10 6
    
    8 4 2
    
    3 10 16 18 21 22 29 30
    
    9 13 16 15
    
    4 2
    
    2 4 7
    
    4 21
    
    4 15 14 5
    
    20 1 15 1 12 5 11

Output

    5
    4
    5
    8
    2
    7
    11

# Annotated Functions:
from collections import *
from math import *
from heapq import *
from bisect import *
import sys
from os import path

class FenwickTree:

    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | i + 1
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """updates bit[idx] += x"""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """calc sum(bit[:end])"""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """Find largest idx such that sum(bit[:idx]) <= k"""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return (idx + 1, k)
class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)

    def insert(self, x):
        i = bisect_left(self.macro, x)
        j = bisect_right(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = (self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:])
            self.micro_size[i:i + 1] = (self.block_size >> 1, self.block_size >> 1)
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        (i, j) = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        (i, j) = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.bisect_right(x) - self.bisect_left(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def bisect_left(self, x):
        i = bisect_left(self.macro, x)
        return self.fenwick(i) + bisect_left(self.micros[i], x)

    def bisect_right(self, x):
        i = bisect_right(self.macro, x)
        return self.fenwick(i) + bisect_right(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
if __name__ == '__main__':
    if path.exists('input.txt'):
        sys.stdin = open('input.txt', 'r')
        sys.stdout = open('output.txt', 'w')
    func_7()

#Function 1:
#State of the program right berfore the function call: func is a function
    d = {}
    return wrapper
    #The program returns the wrapper function, which is a function that is not specified in the initial state, but is presumably defined elsewhere in the code.

#Overall this is what the function does:Returns a wrapper function that is presumably defined elsewhere in the code, without modifying the input dictionary d.

#Function 2:
#State of the program right berfore the function call: args is a tuple of values of any type and d is a dictionary where keys are tuples of values of any type and values are the results of func(*args) for the corresponding key.
    if (args not in d) :
        d[args] = func(*args)
    #State: *args is a tuple of values of any type and d is a dictionary where keys are tuples of values of any type and values are the results of func(*args) for the corresponding key. If args is not in d, d[args] is the result of func(*args) for the current value of args. Otherwise, d remains unchanged.
    return d[args]
    #The program returns the result of func(*args) for the current value of args, which is stored in dictionary d with key args. If args is not in d, it returns the result of func(*args) for the current value of args, otherwise it returns the existing value in d for key args.

#Overall this is what the function does:This function memoizes the result of calling `func` with the provided `args` and returns the cached or newly computed result. It maintains a dictionary `d` to store the results of previous function calls, keyed by the input `args`. If the result for the given `args` is already in the dictionary, it returns the cached value; otherwise, it computes the result using `func(*args)`, stores it in the dictionary, and returns it.

#Function 3:
#State of the program right berfore the function call: No precondition can be extracted from the given function signature as it does not contain any parameters.
    return sys.stdin.readline().strip()
    #The program returns a string that is the first line of input from the standard input, with leading and trailing whitespace removed.

#Overall this is what the function does:Reads the first line of input from the standard input, removes leading and trailing whitespace, and returns the resulting string.

#Function 4:
#State of the program right berfore the function call: func_2() returns a string that represents an integer.
    return int(func_2())
    #The program returns an integer that is represented by the string returned by func_2().

#Overall this is what the function does:Converts a string representation of an integer returned by func_2() to an integer and returns it.

#Function 5:
#State of the program right berfore the function call: delimiter is a string
    return list(map(int, func_2().split(delimiter)))
    #The program returns a list of integers that are obtained by splitting the string returned by `func_2()` using the delimiter string and then converting each split part to an integer.

#Overall this is what the function does:The function takes a delimiter string as input and returns a list of integers. It achieves this by splitting a string obtained from another function (`func_2`) using the provided delimiter, and then converting each resulting part into an integer. The function effectively transforms a string into a list of integers based on a specified delimiter.

#Function 6:
#State of the program right berfore the function call: No precondition can be determined as the function does not have any input parameters.
    return func_2()
    #The program returns the value returned by the function `func_2()`. No specific value can be determined as the function `func_2()` is not defined in the given code snippet.

#Overall this is what the function does:The function calls another function named `func_2()` and returns its result, without performing any additional actions or modifications.

#Function 7:
#State of the program right berfore the function call: n, m, and k are positive integers, A is a list of n non-decreasing integers, D is a sorted list of m unique integers, F is a list of k integers, and inf is a negative infinity value.
    n, m, k = func_4()
    A = func_4()
    D = sorted(set(func_4()))
    F = func_4()
    max_diff, next_max_diff, index = -inf, -inf, None
    for i in range(1, n):
        diff = A[i] - A[i - 1]
        
        if diff > max_diff:
            max_diff = diff
            index = i
        elif diff > next_max_diff:
            next_max_diff = diff
        
    #State: Output State: The maximum difference between consecutive elements in the list A is stored in max_diff, the index of the maximum difference is stored in index, and the second maximum difference is stored in next_max_diff.
    left, right = A[index - 1], A[index]
    ans = max_diff
    for f in F:
        l = bisect_right(D, left - f)
        
        h = bisect_left(D, right - f) - 1
        
        while l < h:
            mid = l + (h - l) // 2
            mid_sum, mid_next_sum = D[mid] + f, D[mid + 1] + f
            if mid_sum - left < right - mid_next_sum:
                l = mid + 1
            else:
                h = mid
        
        if l == h:
            ans = min(ans, max(D[l] + f - left, right - D[l] - f))
        
    #State: The maximum difference between consecutive elements in the list A, index is the index of the maximum difference, next_max_diff is the second maximum difference, left is the element before the maximum difference, right is the element after the maximum difference, and ans is the minimum of the current ans and the maximum of the difference between D[l] + f and left, and the difference between right and D[l] + f.
    print(max(ans, next_max_diff))
    #This is printed: the maximum value between the minimum of the current ans and the maximum of the difference between D[l] + f and left, and the difference between right and D[l] + f, and the second maximum difference between consecutive elements in the list A

#Overall this is what the function does:This function calculates the maximum difference between consecutive elements in a list A and then iterates through a list F to find the minimum difference between the maximum difference and the elements in a sorted list D. It returns the maximum value between the minimum difference found and the second maximum difference between consecutive elements in list A.

#Function 8:
#State of the program right berfore the function call: testcases is a positive integer
    testcases = func_3()
    for _ in range(testcases):
        func_6()
        
    #State: The value of `testcases` is unknown because the function `func_3()` is not defined in the given initial state.

#Overall this is what the function does:Executes a loop a certain number of times, where the number of iterations is determined by the return value of `func_3()`, and calls `func_6()` in each iteration. The final state of the program is that `func_6()` has been called an unknown number of times, as the return value of `func_3()` is unknown.




# Your response:
Reasoning:  
Correctness: **True** or **False**

