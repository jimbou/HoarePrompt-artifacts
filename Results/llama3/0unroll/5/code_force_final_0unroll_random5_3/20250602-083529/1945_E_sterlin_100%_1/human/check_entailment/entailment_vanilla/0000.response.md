Reasoning:

The given program is a solution to the problem described. Here's a step-by-step breakdown of the program's correctness:

1. The program starts by reading the number of test cases `t` using `func_1()`.
2. For each test case, it reads the length of the permutation `n` and the number to be found `x` using `func_2()`.
3. It then reads the permutation `p` using `func_3()`.
4. The program then applies the binary search algorithm to find the position of `x` in the permutation. However, since the permutation is not sorted, it may need to swap elements at most 2 times to get the correct result.
5. The program checks if the element at the found position `l` is equal to `x`. If it is, it outputs 0 and does not perform any swaps.
6. If the element at position `l` is not equal to `x`, it checks if swapping the elements at positions `l` and `l+1` would make the element at position `l` equal to `x`. If it would, it outputs 1 and performs the swap.
7. If swapping the elements at positions `l` and `l+1` would not make the element at position `l` equal to `x`, it checks if swapping the elements at positions `l` and `l-1` would make the element at position `l` equal to `x`. If it would, it outputs 2 and performs the swap.
8. If neither of the above swaps would make the element at position `l` equal to `x`, it outputs 2 and performs both swaps.

The program's logic is correct, and it should produce the expected output for the given problem.

Correctness: **True**