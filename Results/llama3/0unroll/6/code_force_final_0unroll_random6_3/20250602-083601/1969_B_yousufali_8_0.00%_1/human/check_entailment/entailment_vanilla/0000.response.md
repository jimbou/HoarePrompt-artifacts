Reasoning:

The problem asks to find the minimum total cost to make a binary string sorted in non-descending order by performing cyclic shifts on substrings. The cost of each operation is equal to the length of the chosen substring.

Function 1 (`func_1`) reads a binary string from input, converts it to a list of integers, and then iterates over the list. It maintains a counter `n` for the number of consecutive 1's encountered so far. Whenever it encounters a 0 and `n` is not zero, it increments the answer by `n + 1`. This is because a cyclic shift of length `n + 1` is needed to move the `n` consecutive 1's to the right of the 0.

Function 2 (`func_2`) reads the number of test cases from input and calls `func_1` for each test case.

The program is correct because it correctly implements the logic to find the minimum total cost. The key insight is that whenever a 0 is encountered after a sequence of 1's, a cyclic shift of length `n + 1` is needed to move the 1's to the right of the 0. By summing up these lengths, the program calculates the minimum total cost.

However, there is a small issue with the input reading in `func_1`. The problem statement says that the input is a binary string, but `func_1` reads it as a list of integers using `map(int, input().split())`. This would work if the input string is space-separated, but the problem statement does not guarantee this. A more robust way to read the input would be to use `input()` to read the entire string and then iterate over its characters.

Correctness: **True** (with a minor caveat about input reading)